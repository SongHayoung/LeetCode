class Solution {
    vector<int> g;
    unordered_map<int, int> counts;
    unordered_map<int, vector<int>> inits;
    int find(int n) {
        return g[n] == n? n : g[n] = find(g[n]);
    }
    void uni(int a, int b) {
        int pa = find(a), pb = find(b);
        g[pa] = g[pb] = min(pa,pb);
    }    
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        g = vector<int>(n);
        for(int i = 0; i < n; i++) g[i] = i;
        for(int i = 0; i < n; i++) {
            for(int j = i + 1; j < n; j++) {
                if(graph[i][j]) {
                    uni(i,j);
                }
            }
        }
        sort(initial.begin(), initial.end());
        for(int i = 0; i < n; i++) {
            counts[find(i)]++; //group counts
        }
        for(int init : initial) {
            inits[find(init)].push_back(init); //how many init nodes in group
        }
        int stopCount = 0;
        int res = INT_MAX;
        
        for(auto [group, initNodes] : inits) {
            if(initNodes.size() == 1) {
                if(stopCount < counts[group]) {
                    stopCount = counts[group];
                    res = initNodes[0];
                } else if(stopCount == counts[group]) {
                    res = min(res,initNodes[0]);
                }
            } else if(stopCount == 0){
                res = min(res, initNodes[0]);
            }
        }
        return res;
    }
};