class Solution {
    int uf[333], cnt[333];
    int find(int u) {
        return uf[u] == u ? u : uf[u] = find(uf[u]);
    }
    void uni(int u, int v) {
        int pu = find(u), pv = find(v);
        if(pu != pv) {
            cnt[pu] = cnt[pv] = cnt[pu] + cnt[pv];
            uf[pu] = uf[pv] = min(pu,pv);
        }
    }
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& A) {
        int n = graph.size();
        for(int i = 0; i < n; i++) uf[i] = i, cnt[i] = 1;
        for(int i = 0; i < n; i++) for(int j = i + 1; j < n; j++) {
            if(graph[i][j]) uni(i,j);
        }
        unordered_map<int, int> inf;
        for(auto& x : A) inf[find(x)]++;
        int ma = 0, who = -1;
        for(auto& x : A) {
            int r = find(x);
            if(inf[r] != 1) continue;
            int now = cnt[r];
            if(ma < now) {
                ma = now, who = x;
            } else if(ma == now) who = min(who, x);
        }
        if(who == -1) return *min_element(begin(A), end(A));
        return who;
    }
};