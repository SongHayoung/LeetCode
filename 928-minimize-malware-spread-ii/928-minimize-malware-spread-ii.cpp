class Solution {
    vector<int> g;
    unordered_map<int, int> counts;
    unordered_map<int, vector<int>> inits;
    vector<vector<int>> edges;
    int find(int n) {
        return g[n] == n? n : g[n] = find(g[n]);
    }
    void uni(int a, int b) {
        int pa = find(a), pb = find(b);
        g[pa] = g[pb] = min(pa,pb);
    }
    int verify(int removeNode, vector<int>& init) {
        queue<int> q;
        unordered_set<int> v;
        int infect = 0;
        for(int node : init) {
            if(node == removeNode) continue;
            v.insert(node);
            q.push(node);
            infect++;
        }
        while(!q.empty()) {
            auto node = q.front(); q.pop();
            for(auto near : edges[node]) {
                if(near == removeNode or v.count(near)) continue;
                v.insert(near);
                q.push(near);
                infect++;
            }
        }
        return infect;
    }
    //count, node pair
    pair<int,int> getSpreadStopCount(int groupId, vector<int>& initNodes) {
        if(initNodes.size() == 1) {
            return {counts[groupId], initNodes[0]};
        }
        int count = 0;
        int node = INT_MAX;
        for(auto removeNode : initNodes) {
            int infectCount = verify(removeNode, initNodes);
            int protectNodes = counts[groupId] - infectCount;
            if(count < protectNodes) {
                node = removeNode;
                count = protectNodes;
            }
            else if(count == protectNodes)
                node = min(node, removeNode);
        }
        return {count, node};
    }
    
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        g = vector<int>(n);
        edges = vector<vector<int>>(n);
        for(int i = 0; i < n; i++) g[i] = i;
        for(int i = 0; i < n; i++) {
            for(int j = i + 1; j < n; j++) {
                if(graph[i][j]) {
                    uni(i,j);
                    edges[i].push_back(j);
                    edges[j].push_back(i);
                }
            }
        }
        for(int i = 0; i < n; i++) {
            counts[find(i)]++; //group counts
        }
        for(int init : initial) {
            inits[find(init)].push_back(init); //how many init nodes in group
        }
        int stopCount = 0;
        int res = INT_MAX;
        
        for(auto [group, initNodes] : inits) {
            auto [count, node] = getSpreadStopCount(group, initNodes);
            if(count == stopCount) {
                res = min(res, node);
            }
            else if(count > stopCount) {
                stopCount = count;
                res = node;
            }
        }
        return res;
    }
};